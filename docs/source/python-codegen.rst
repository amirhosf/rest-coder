Python Client Stub Generator
============================

The RESTCoder's Python client stub generator can be used to quickly and easily generate Python modules that can consume remote web APIs. The generated code handles data marshaling, unmarshaling, HTTP invocation and also in many cases error handling, thereby relieving the mashup and application developers from having to manually implement all that logic. If the input API description is properly documented, the Python code generated by the stub generator would have proper docstrings describing each of the auto-generated methods. By auto-generating code that masks all the complexities of communicating with a remote API, this tool greatly simplifies the process of developing mashups, desktop applications, command-line tools and webapps that rely on remote web services.

Following sections describe how to use the code generator and what to expect as its output.

Using the Python Code Generator
-------------------------------

The Python client stub generator requires Python 2.7 to be installed. If Python 2.7 is already installed, simply head over to the ``bin`` directory of the RESTCoder installation and execute the script named ``codegen.py`` as follows. ::

  ./codegen.py -f /path/to/api/description.json -o mymodule.py

This will generate a Python module named ``mymodule.py`` which can be used as a client stub (proxy) to consume the remote API described in ``description.json``.

It is also possible to load the input API description from a HTTP/S URL. ::

  ./codegen.py -u http://example.com/description.json -o mymodule.py

By default the HTTP ``OPTIONS`` method will be used to pull the API description from the input URL. To use a different method use the ``-m`` flag.

To see the full list of command line options supported by the Python code generator, run ``codegen.py`` with the ``-h`` flag. ::

  ./codegen.py -h

Generated Code
--------------

Python code generated by the client stub generator can be executed on any Python 2.7 runtime. The generated code is also highly backwards compatible with Python 2.6. The auto-generated code relies on following built-in Python modules.

 * `sys <http://docs.python.org/2/library/sys.html>`_
 * `urlparse <http://docs.python.org/2/library/urlparse.html>`_
 * `httplib <http://docs.python.org/2/library/httplib.html>`_
 * `json <http://docs.python.org/2/library/json.html>`_
 * `urllib <http://docs.python.org/2/library/urllib.html>`_

The generated code may also rely on the ``api.py`` module shipped with the RESTCoder distribution. This module can be found in the ``python-lib`` directory of RESTCoder.

The Python code generator, generates a separate Python class for each resource defined in the API description. The class is usually has the same name as the resource with the suffix ``Client`` appended to it. Operations of a resource are converted into methods of the corresponding generated class. Therefore if a particular input API description has a resource named ``OrderManager`` which has the operations ``getOrder`` and ``submitOrder``, the code generator would generate a Python class named ``OrderManagerClient`` which has the functions ``getOrder()`` and ``submitOrder()``. The input parameters of the two operations would be turned into Python method arguments and the output of the operations would be turned into return types.

The code generator would also generate separate classes for each of the data types defined in the input API description. Instances of these classes will be used as input arguments and return objects where appropriate. A separate set of static methods would be generated which handles serialization and deserialization of Python objects.

Media Types
-----------

As of now the Python code generator can only generate code for JSON based APIs. If the input API description uses other media types, the code generator would create some place holder serialization/deserialization functions which simply raises the `NotImplementedError` exception.

It is trivial to add support for other media types in the code generator tool. Simply implement a serializer class extending the ``AbstractSerializer`` class of the ``serializers.py`` module. In this class, specify how to recursively convert a Python object into a byte string in the target media type and how to covert a byte string into a Python object. 